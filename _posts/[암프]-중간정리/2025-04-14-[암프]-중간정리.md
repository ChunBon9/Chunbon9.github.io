---
title: "[암프] 중간정리"
date: 2025-04-14 20:45:00 +09:00
tags: [study, 암호프로토콜]
usemathjax: true
---

### Computing power of users(attackers)
- Infinite
- ppt (probabilitive polynomial time)

### A negligible function
$$
\begin{align*}
&f: N\rightarrow R\text{ such that for every positive integer }c,\text{ there exists an integer }N_c \text{ such that for all }x > N_c \\
\end{align*}
$$

$$
|f{(x)}| < \frac{1}{x^c}
$$

어떤 임계치 \\(N_c\\)를 넘어가면 어떤 다항식의 역함수보다 빠르게 0으로 수렴하는 함수  
시스템을 뚫을 확률이 현실적으로 의미없다를 수학적으로 표현하기 위해 쓰임

#### properties
- If \\(f, g\\) are negligible function, the \\(f + g\\) is negligible
- If \\(f\\) is negligible and \\(p\\) is any polynomial, then \\(p \cdot f\\) is negligible

### One-way function
$$
\text{If it is hard to find x given }f{(x)}, f{(x)}\text{ is one-way function}
$$

역산이 어려우면 OWF

$$
\begin{align*}
&\text{A hardcore predicate of one-way function }f\text{ is a predicate }h\\
&\text{ which is easy to compute }h(r)\text{ as a function of }r,\text{ but hard to compute given }f(r)
\end{align*}
$$

출력만으로는 입력을 알아낼 수 없다를 보장하는 함수

#### Constructions of hardcore predicates
**simple idea**

\\(f(x)\\): one way function<br>\\(h(x)\\): \\(\oplus^{n}_{i=1}x_i\\)

모든 비트를 알아야지 \\(h(x)\\) 계산 가능 \\(f(x)\\)로는 계산 불가능  
그러나 만약 \\(g(x) = (x, \oplus^{n}_{i=1}x_i)\\) 형태의(입력의 정보를 유출하는) OWF 경우에는 사용 못함 그래서 나온 것이

#### Goldreich and Levin's consturction
$$
\begin{align*}
&\text{Let }f\text{ be a OWF} \\
&\text{Another OWF }g(x, r) = (f(x), r)\text{ for }|x| = |r| \\
&\text{Hardcore predicate }h(x, r)\text{ for }g \\
\end{align*}
$$



$$
h(x, r) = \oplus^{n}_{i=1}x_{i}r_i
$$

r은 랜덤값, 무작위 비트를 이용하기에 항상 통과하려면 모든 비트의 정보를 유출해야함  
\\(\rightarrow\\) OWF 정의 위배, 고로 안전하다

### Commitment Schmes
- commit phase 

Sender가 메세지를 암호화 해서 전달하는 단계

- reveal phase

키를 전송하여 Receiver가 열어서 확인하는 단계

$$
\begin{align*}
\text{A triple of algorithm }(KGen, &Com, Ver)\text{ is called a commmitment scheme} \\
&pk \leftarrow KGen(1^k) \\
&(c, d) \leftarrow Com(m, pk) \\
&0/1 \leftarrow Ver(pk, m, c, d)
\end{align*}
$$

#### security properties
- correctness:  
\\(Pr[Ver(pk, m, c, d) = 1 | pk \leftarrow KGen(1^k), m \in M, (c,d) \leftarrow Com(m, pk)] = 1\\)

알고리즘이 제대로 되어 있다면 Ver결과는 1

- binding:  
If \\(Ver(pk, m, c, d) = 1\\) and \\(Ver(pk, m', c, d') = 1\\), then \\(m, m'\\) with an overwhelming probability

하나의 commitment \\(c\\)에 대해서 한 쌍의 \\((m, d)\\)만 가능하다

- hiding: 

$$
\begin{align*}
Game&_{Com_{A}^b}(1^k)\qquad b\in \{0, 1\} \\
&pk \leftarrow kGen(pk) \\
&(m_0, m_1) \leftarrow A(pk) \\
&(c, d) \leftarrow Com(m_b, pk) \\
&b' \leftarrow A(c)
\end{align*}
$$

$$
\text {For every }A, \; Pr[Game_{com_A^1}(1^k) = 1] - Pr[Game_{com_A^0}(1^k) = 1] \text{ is negligible in }k
$$

\\(d\\) 없이는 \\(c\\)에서 \\(m\\) 유추 불가능

### Two type of commitment schemes
- standard
    - information-theoretically binding
    - computationally hiding

- perfect
    - computationally binding
    - information-theoretically hiding

computationally - ppt에게게 불가능  
information-theoretically - 아예 불가능

**standard commitment sheme 구현 예시**

- one-way permutation 이용

$$
\begin{array}{lcl}
S & &R\\
f \leftarrow Gen(1^k)\\
r \leftarrow \{0, 1\}^k\\
&\text{commit}\\ 
&\rightarrow f, c=f(r), e = h(r) \oplus m\rightarrow\\
&\\
&\text{reveal}\\
&\rightarrow d = r, m\rightarrow \\
& &f(r) == c \\
& &m == e \oplus h(r)\\
\end{array}
$$

\\(r\\)값에 대해해\\(h(r)\\)값 단 하나만 존재하기에 \\(m\\)에 대해서 \\(e\\) 단 하나만 가능  
\\(\rightarrow\\) information-theoretically binding

\\(m\\)에 대해서 \\(e\\) 단 하나만 가능하기에 가능한 모든 \\(r\\)을 시도해 \\(f(r)\\)값 찾을 수도 있음(O(2^k))  
\\(\rightarrow\\) computationally hiding

**perfect commitment sheme 구현 예시**

- DLP 이용

$$
\begin{array}{lcl}
S & &R\\
& & \text{generate a cyclic group }G \text{ of prime order } q\\
& & \text{pick random generators } g,h \in G\\
&\leftarrow g, h, G, q\leftarrow\\
r\leftarrow Z_g\\
c\leftarrow g^mh^r\\
&commit\\
&\rightarrow r \rightarrow\\
& \\
&reveal\\
&\rightarrow m,r \rightarrow\\
& & c == g^mh^r
\end{array}
$$

\\(c = g^mh^r = g^{m'}h^{r'}, \; (m, r) \neq (m', r')\\) 동일한 쌍은 존재함  
\\(g^mh^r = g^{m+\alpha r} = g^{m'+\alpha r'}\; \alpha = \frac{m'-m}{r-r'}\\) 그러나 그것을 찾는 것은 \\(\alpha \\)를 찾았다는 것이고 그것은 \\(h = g^\alpha \\)를 풀었다는 것  
\\(\rightarrow\\) computationally binding

For any value \\(c\\), there are exactly \\(q\\) possible pairs \\((x,r)\\) satisfying \\(c = g^mh^r\\) 답이 되는 쌍이 다수이기에 무엇이 정답인지 확정 불가능  
\\(\rightarrow\\) information-theoretically hiding

### Oblivious Transfer (Private Information Retrieval)
$$
\begin{array}{lcl}
Sender & &Receiver\\
(M_1, M_2) & &(b \in \{0, 1\}) \\
&\leftarrow b \leftarrow\\
&\rightarrow M_b \rightarrow
\end{array}
$$

#### properties
- The sender can transmit one of several messages
- The receiver can select and receive only one of them
- The sender cannot know which message was chosen
- receiver cannot gain any information about messages they did no select

#### 1-out-of 2 OT

**use RSA**

$$
\begin{array}{lcl}
S & &R\\
(d, e, n) & &(e, n)\\
x_0, x_1 \leftarrow Z_p \\
&\rightarrow x_0, x_1 \rightarrow \\
&&k \leftarrow Z_p\\
&&v \leftarrow x_b + k^e\\
&\leftarrow v \leftarrow \\
m'b = (v - x_b)^d \\
&\rightarrow m'_0, m'_1\rightarrow \\
&&m_b = m'_b - k
\end{array}
$$

\\(x_0 + k^e = x_1 + k^{e'}\\) 가능하기에 선택 알 수 없음  
\\(m'_b = m_b + k or m_{1-b} + (x_b - x_{1-b} - k^e)^d\\)이기에 선택한 \\(m_b\\)만 복구 가능

**use DLP**

$$
\begin{array}{lcl}
S & &R\\
a \leftarrow Z_p&&b \leftarrow Z_p \\
&\rightarrow A = g^a \rightarrow \\
&&\text{if }c = 0\; B = g^b\\
&&\text{if }c = 1\; B = A \cdot g^b\\
&\leftarrow B \leftarrow \\
k_0 = H(B^a) \\
k_1 = H((\frac{B}{A})^a) \\
e_0 = E_{k_0}(M_0) \\
e_1 = E_{k_1}(M_1) \\
&\rightarrow e_0, e_1\rightarrow \\
&&k_c = H(A^b) \\
M_c = D_{k_c}(e_c)
\end{array}
$$

\\(g^b = A \cdot g^{b'}\\)가 가능하기에 선택 알 수 없음
\\(k_0 = H(g^{ab}) or H(g^{a^2 + a+b}), k_1 = H(g^{ab}) or H(g^{ab - a^2})\\)가 되기에 \\(a\\)를 모르면 다른 \\(M\\)을 복구할 수 없음

#### 1-out-of-4 OT
$$
\begin{array}{lcc}
&c_0c_1 \\
a_0 = S_0 \oplus S_2 \oplus m_0 &0\,\,\,0:& m_0\\ 
a_1 = S_0 \oplus S_3 \oplus m_1 &0\,\,\,1:& m_1\\
a_2 = S_1 \oplus S_4 \oplus m_2 &1\,\,\,0:& m_2\\
a_3 = S_1 \oplus S_5 \oplus m_3 &1\,\,\,1:& m_3\\
\end{array}
$$

$$
\begin{array}{lcl}
S_0 \rightarrow && \leftarrow c_0 \\
\\[-18 pt]
&\boxed{1-2\;\, OT} \\
\\[-18 pt]
S_1 \rightarrow && \rightarrow S_i \\
\\
S_2 \rightarrow && \leftarrow c_1 \\
\\[-18 pt]
&\boxed{1-2\;\, OT} \\
\\[-18 pt]
S_3 \rightarrow && \rightarrow S_j \\
\\
S_4 \rightarrow && \leftarrow c_1 \\
\\[-18 pt]
&\boxed{1-2\;\, OT} \\
\\[-18 pt]
S_5 \rightarrow && \rightarrow S_k \\
\end{array}
$$

**4개를 구분하는 것이면 \\(S_i\\)가 4개면 충분한데 왜 6개나?**  
\\(S_4, S_5\\)대신 \\(S_2, S_3\\)을 쓸 경우 \\(a_0 \oplus a_1 \oplus a_2 \oplus a_3 = m_0 \oplus m_1 \oplus m_2 \oplus m_3\\)이라서 \\(m\\)하나만 얻으면 다른 \\(m\\)들의 일부 정보가 유출  
\\(\rightarrow \\)properties에서 네 번째 거 위배

#### 1-out-of-N OT from 1-out-of-2
**<scheme 1>**

$$
\begin{array}{rcl}
r_1 \rightarrow && \leftarrow \\
\\[-25 pt]
&\boxed{1-2\;\, OT} \\
\\[-25 pt]
x_1 \rightarrow && \rightarrow \\
\\
r_2 \rightarrow && \leftarrow \\
\\[-25 pt]
&\boxed{1-2\;\, OT} \\
\\[-25 pt]
r_1 \oplus x_2 \rightarrow && \rightarrow \\
\\
r_3 \rightarrow && \leftarrow \\
\\[-25 pt]
&\boxed{1-2\;\, OT} \\
\\[-25 pt]
r_1 \oplus r_2 \oplus x_3 \rightarrow && \rightarrow \\
\end{array}
$$

앞 단계에서 얻은 결과를 순차적으로 xor  
\\(\rightarrow O(n)\\)

**<scheme 2>**  
Naor and Pinkas's scheme  
For each \\( i \in \{0, 1, \dots, n - 1\} \\), let \\( i = (b^i_1, b^i_2, \dots, b^i_{log^{n}_{2}})_2 \\)<br>


$$
\begin{array}{rcl}
S^1_0 \rightarrow && \leftarrow b^i_1\\
\\[-18 pt]
&\boxed{1-2\;\, OT} \\
\\[-18 pt]
S^1_1 \rightarrow && \rightarrow S^1_{b^i_1}\\
\\
S^2_0 \rightarrow && \leftarrow b^i_2\\
\\[-18 pt]
&\boxed{1-2\;\, OT} \\
\\[-18 pt]
S^2_1 \rightarrow && \rightarrow S^2_{b^i_2}\\
\\
S^3_0 \rightarrow && \leftarrow b^i_3\\
\\[-18 pt]
&\boxed{1-2\;\, OT} \\
\\[-100 pt]
S^3_1 \rightarrow && \rightarrow S^3_{b^i_3}\\
\end{array}
$$

이분 탐색 느낌으로 \\(i\\)의 비트 값을 이용해 앞 부분 부터 받아옴  
\\(\rightarrow O(log_n)\\) 
